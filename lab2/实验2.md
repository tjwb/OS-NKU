# Lab2 物理内存和页表
## 一、练习1：理解first-fit 连续物理内存分配算法
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，主要思想是从空闲链表头开始，找到第一个连续的物理内存块，然后返回该块。需要保证该空闲块的大小符合我们需要分配的内存的大小。free_list是物理内存管理模块中定义的空闲链表，该链表用于记录空闲的区域，它的节点是每一个空闲区域的第一个page页面，并不是将所有空闲页面都添加到free_list中。

### （一）page结构体
在实验开始之前有必要先介绍一下page结构体，page结构体是内核中物理内存管理模块的内核数据结构，它用于描述页结构体。具体的结构定义如下：
```
struct Page {
    int ref;                 // page frame's reference counter
    uint64_t flags;          // array of flags that describe the status of the page frame
    unsigned int property;   // the num of free block, used in first fit pm manager
    list_entry_t page_link;  // free list link
};
```
其中一个page结构体节点相当于内存当中的一个物理页，这个结构体标识了一个物理页的属性，如页的引用计数（ref），页的属性，页是否被分配，以及一个用于标识有多少个空闲块的字段property等。
page结构体中定义了page_link，这个指针用于在空闲链表中进行链表操作，当内存被分配的时候，空闲页链表会进行相应的修改，这个时候就会用到节点的page_link指针。

• ref为该⻚帧的引⽤计数器，也就是映射此物理⻚的虚拟⻚个数，在增加映射时递增，取消映射时递减；

• flags是描述该⻚状态的标记数组，其含有PG_reservedPG_property两个成员，前者表⽰该⻚是否被内核占⽤（1/0），后者表⽰该⻚是否为⼀段空闲内存块的⾸⻚(1/0)。

• property⽐较特殊，其记录连续空闲⻚的数量。该变量仅在PG_property标志位为1时有效，作为空⽩⻚⾯分配时的重要参数。

• page_link是把多个连续内存空闲块链接在⼀起的双向链表指针。连续内存空闲块利⽤这个⻚的成员变量page_link来链接⽐它地址⼩和⼤的其他连续内存空闲块，在分配，释放过程都起作⽤。
### （二）first-fit算法介绍
first-fit算法是物理内存分配算法的一种，它从空闲链表头开始，找到第一个连续的物理内存块，然后返回该块。需要保证该空闲块的大小符合我们需要分配的内存的大小。
#### 1.default_init函数
```
static void
default_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```
default_init函数用于初始化first-fit算法，首先初始化空闲链表，然后设置空闲页的数目为0。
#### 2.default_init_memmap函数
```
default_init_memmap(struct Page *base, size_t n)
```
在这个函数中，主要做的是初始化操作，传入的参数包括base即空闲页面的起始地址，和空闲页面的数量n。初始化物理页面的属性，然后将整个空闲块加入到空闲链表free_list中。这里往空闲链表中加入节点的过程中也只是加入每一个连续空闲区域的第一个页，即base。然后加入的base在链表中是按照地址从小到大排列的。
#### 3.default_alloc_pages函数
```
static struct Page *
default_alloc_pages(size_t n)
```
这个函数用于分配物理内存，传入的参数是需要分配的物理页面的大小n。如果链表链接的空闲区域中存在满足分配n个物理空闲页的区域，那么就把第一次匹配到的满足分配条件的空闲区域返回，否则返回NULL。
分配完成以后，会将分配的物理页从空闲链表中删除，并将物理页的引用计数加1，同时将物理页的属性重置。如果该空闲区域分配n个空闲页以后还剩下空闲页，需要将该空闲区域链接到空闲链表中，以供下次使用。

#### 4.default_free_pages函数
```
static void
default_free_pages(struct Page *base, size_t n) 
```
该函数用于释放和回收空闲页，传入的参数包括base即空闲区域的起始地址页，以及回收的空闲页的数量n。
先通过遍历将这n个页面的属性设置为空闲，然后通过将base和base+n之间的空闲区域链接到空闲链表中。
最后需要判断该空闲区域是否是和前一个空闲区域相连接，如果是，则将前一个空闲区域的property加n，即合并前后的区域，对于与后一个空闲区域的关系同理。

### （三）first fit算法是否有进一步的改进空间
1.在这个算法中，在多次分配以后可能会产生很多碎片内存块，导致内存的利用率低，浪费空间。可以在一个固定分配次数以后，将空闲链表中的连续空闲块合并，减少内存的碎片。

2.由于在分配的过程中，必须从kongxian链表头开始遍历，如果链表过长，可能会导致时间复杂度较高。这里可以采用多个链表，将链表分为多个段，分别链接小块、中块、大块等，这样在分配的时候，可以减少遍历的时间。

## 二、练习2：实现 Best-Fit 连续物理内存分配算法
Best_fit算法的调用过程和first_fit算法一致，只是算法实现不同。在first_fit算法中，是直接从空闲链表的头开始遍历，找到第一个满足分配条件的空闲块，然后返回。而best_fit算法是遍历整个空闲链表，找到满足分配条件的最小的空闲块，然后返回。这里需要维护一个变量best_fit_ptr，用于记录当前找到的最小空闲块。
### （一）算法分配
代码中主要是在分配内存部分两个算法存在出入，现在将best_fit算法的代码实现逻辑展示如下：
```
 /*LAB2 EXERCISE 2: YOUR CODE*/ 
    // 下面的代码是first-fit的部分代码，请修改下面的代码改为best-fit
    // 遍历空闲链表，查找满足需求的空闲页框
    // 如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            page = p;
            break;
        }
       if (p->property >= n && p->property <min_size) { 
            page = p; //当前的最佳匹配
            min_size=p->property; //更新最小内存块大小
        }
    }
```
    
这里使用了min_size用来存储此时找到的最小的空闲块的大小，然后在遍历的过程中，如果找到的空闲块的大小小于min_size，那么就将page指向该空闲块，然后更新min_size的值。（这里需要保证空闲块大小至少需要满足他的分配需求）

### （二）算法释放
```
    if (p + p->property == base) {
            p->property += base->property;
            ClearPageProperty(base);
            list_del(&(base->page_link));
            base = p;
        }

    le = list_next(&(base->page_link));
    if (le != &free_list) {
        p = le2page(le, page_link);
        if (base + base->property == p) {
            base->property += p->property;
            ClearPageProperty(p);
            list_del(&(p->page_link));
        }
    }

static size_t
best_fit_nr_free_pages(void) {
    return nr_free;
}
```
best_fit的释放策略与first_fit算法的释放策略是一致的，首先都是将需要释放的空闲块添加到空闲链表中，然后通过遍历空闲链表，将空闲块链接到一起。判断添加的这个空闲块是否和链表上的前一个空闲块以及后一个空闲块相连，如果相连就把他们合并，同时将前一个空闲块的属性加到后一个空闲块上，这样空闲链表就保持了连续性。最后将释放的页面数量添加到总空闲页面中。
### （三）best_fit算法的运行效果图
![best_run](https://github.com/tjwb/OS-NKU/blob/main/image/best_fit_run.png)
### （四）best_fit算法是否有改进空间
1.同样，针对best_fit算法，同样会产生内存碎片，因此可以考虑在多次分配以后，将空闲链表中的连续空闲块合并，减少内存的碎片。处理策略同first_fit算法一致。

2.针对best_fit算法，每一次分配或者回收都需要遍历整个链表，我们是不是可以采用索引或者是树等数据结构来优化算法的查找效率。


## 三、challenge 1：buddy system（伙伴系统）分配算法	
Buddy_pmm的内存管理方式是，把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...。在本次实验中，要使用伙伴分配器，则要管理的块（即页框）数目为2^14即16384。

伙伴分配器结构中，最核心的结构为链表数组buddy_array[16]。其功能类似于基础实验中的空闲链表free_area，可以将buddy_array理解为一个由很多free_area组成的数组。其具体应用为：当初始化了一段有2^n个连续块的空闲内存空间时，将该内存空间的首个page连接至buddy_array中下标为n的那个链表头上。亦即，对于buddy_array中的每一个下标为n的链表，其都类似于一个free_area，但其连接的应该是所有大小为2^n块的连续内存空间的首个page。在进行内存分配和释放时都用到了这个核心结构。

在初始化时，即将一整块要用于管理的内存进行初始化。整个内存此时均为空，此时初始化即为将整个内存的首个page连接至buddy_array[14]。

以下为分配与释放的具体实现：
### （一）分配：
需要分配一个大小为real_n的内存块时，首先需要将real_n增大到为2的幂次进行分配。获得n为比real_n大的、2的最小次幂。

然后进入循环。循环内,

1.首先对buddy_array内的链表进行遍历，寻找链表数组内下标为n的链表上有没有连接（这代表有无与n大小刚好相同的空闲内存块）。若有，则直接从该链表上断开要分配的空闲块，此时完成内存分配，break。

2.若没有，顺着数组下标继续遍历，直至找到第一个比n大的空闲块。此时，将该空闲块从原先的链表上取下，平分为两个新的空闲块，并将两块都连接至下标-1的链表上。然后进入下一次循环。

因此，只有正好分割出大小为n的空闲块时，才会在第一步中终止循环。否则，则会重复第二步直至分割出两个大小为n的空闲块，并在下次循环中将其中之一进行分配。

在分配过程时，由同一个大空间所分割而产生的两个小空间，即为伙伴空间。伙伴空间即是需要在释放时进行合并的。分割产生的两个小空间中，原先在头部的为左空间，原先在尾部的为右空间。
### （二）释放：

释放时，根据释放出的空闲内存所包含的块的数量，将其连接至buddy_array内对应下标的链表上（当释放了一段有2^n个连续块的内存空间时，将该内存空间的首个page连接至buddy_array中下标为n的那个链表头上）。然后，需要进行是否合并的检查。

对刚刚释放的空闲内存空间，根据其首个page的物理地址，可以找到其伙伴空间的物理地址，并进一步可以返回其伙伴空间的首个page的指针。在释放一部分空间时，就需要检查该空间的伙伴空间是否也是空闲的，若为空闲，则将其合并；此时需要进行其位置的判断，因为我们只能将右块合并至左块上，然后将合并完的大块连接至下表+1的链表上。此时，对这个大块接着执行上述逻辑，检查大块的伙伴空间，并执行是否合并的操作。



## 四、(Challenge3)思考题：硬件的可用物理内存范围的获取方法?
**Question**:如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？
**Answer**:在操作系统中，内存管理是操作系统的一个重要功能，它涉及到内存的分配、回收、保护和映射等操作。在操作系统启动时，需要知道可用的物理内存的范围，以便进行内存管理。以下是一些可能的方法：
1.通过BIOS接口获取：在启动阶段，BIOS（Basic Input/Output System，基本输入/输出系统）通过一些接口（如INT15H）可以获取到物理内存的地址和长度。

2.通过硬件检测：有些硬件设备（如内存条）也会提供内存信息，例如DIMM插槽信息。

3.通过操作系统提供的API：操作系统可能会提供一些API，允许用户程序查询可用的物理内存范围。

4.通过硬件的自检：有些硬件会在启动时进行自检，自检的结果中可能包含了可用的物理内存的信息。

5.通过用户输入：在启动阶段，用户可能也会输入一些关于物理内存的信息，例如内存条的数量和大小等。
